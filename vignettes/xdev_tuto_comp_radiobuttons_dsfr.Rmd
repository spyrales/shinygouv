---
title: "radioButtons_dsfr"
output: html_vignette
vignette: >
  %\VignetteIndexEntry{xdev_tuto_comp_radiobuttons_dsfr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(shinygouv)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/flat_composants/flat_radioButtons.Rmd: do not edit by hand -->

Le développement du composant shiny `radioButton_dsfr` nécessite quelques étapes supplémentaires.
En effet, le code html de ce type de composant se structure en plusieurs htmlTemplates.

```
<div class="fr-form-group">
    <fieldset class="fr-fieldset">
        <legend class="fr-fieldset__legend fr-text--regular" id='radio-legend'>
            Légende pour l’ensemble de champs
        </legend>
        <div class="fr-fieldset__content">
            <div class="fr-radio-group">
                <input type="radio" id="radio-1" name="radio">
                <label class="fr-label" for="radio-1">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-2" name="radio">
                <label class="fr-label" for="radio-2">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-3" name="radio">
                <label class="fr-label" for="radio-3">Label radio
                </label>
            </div>
        </div>
    </fieldset>
</div>
```

Il est donc nécessaire de scinder les htmlTemplates dans différents fichiers .html.
Suivre les 2 premières étape de la procédure décrite dans `dev/documentation/comment-faire-un-composant-shiny.Rmd` uniquement pour la partie `<div class="fr-radio-group">`.

Quelques précisions:  

- Pour utiliser le fonctionnement classique du radioButtons {shiny}:  
  - l'argument `value` a été rajouté  
  - la classe `shiny-options-group` a été rajoutée (ce qui permettra d'implémenter/utiliser une fonction `updateRadioButtons_dsfr()`)  
  - reprendre la div `label` du radioButtons de shiny ainsi que ses attributs.  
  

# radioButtons_unique_dsfr_template

Avant l'utilisation de `htmlTemplate()`, notre fonction nécessite de considérer les différents cas de figure pour certains paramètres.
Par exemple, l'utilisation ou non d'un vecteur nommé doit modifier la personnalisation du template `.html` (si le vecteur n'est pas nommé alors le `nom_choix` doit être égal au `value_choix`).



```{r eval = FALSE}
radioButtons_unique_dsfr_template <- function(inputId, choix, nom_choix, name, inline = FALSE
  ){
  
  if(isTRUE(inline)){
    class_inline <- "-inline"  
  } else { 
    class_inline <- NULL}
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "radiobouton.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    name = name,
    nom_choix = nom_choix,
    value_choix = choix,
    class_inline = class_inline 
    )
}
```

  
  

Le travail précedemment réalisé, peut maintenant être répété au niveau de la `<div class="fr-form-group">`:

- 2 première étape de la procédure `dev/documentation/comment-faire-un-composant-shiny.Rmd`.


# radioButtons_dsfr_template

De la même manière que pour la fonction précédente, il est nécessaire d'adapter la personnalisation en fonction des paramètres passés en arguments.
Cette fonction repose sur `radioButtons_unique_dsfr_template()` qui devra être répéter autant de fois qu'il y a de choix (utilisation de `purrr::map(...)`)


```{r eval = FALSE}
radioButtons_dsfr_template <- function(inputId, label, choix, inline = FALSE,  class = NULL
  ){
  inline <- FALSE #TODO 
  if (isTRUE(inline)){
    class_inline <- "fr-fieldset--inline"
    class <- "shiny-input-container-inline"
  } else {
    class_inline = NULL
  }

  if (is.null(names(choix))) {
    nom_choix <- choix
  } else {
    nom_choix <- names(choix)
  }

  
  x <- 0
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant",
      "radiobouton_group.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    label = label,
    choix = purrr::map2(.x = choix,
                        .y = nom_choix
                       ~ {
                         x <<- x+1
                         radioButtons_unique_dsfr_template(
                           inputId = paste0(inputId,"-", x),
                           name = inputId,
                           choix = .x,
                           nom_choix = nom_choix,
                           inline = inline
                         )
                       }) %>%
      htmltools::tagList(),
    inline = class_inline, 
    class = class
  )
}
```

  
  

L'implementation de la fonction `radioButtons_dsfr()` reste quant à elle similaire à la suite de la procédure.


# radioButtons_dsfr

```{r examples-radioButtons_dsfr}
radioButtons_dsfr(
      inputId = "test", label = "Test", choices = c("A","B"), class = NULL
)

# radioButtons_dsfr(
#       inputId = "test",
#       label = "Test",
#       choices = c("Choix A" = "A","Choix B" = "B"),
#       class = NULL
# )
```

# updateRadioButtons_dsfr

    

  

```{r example-updateRadioButtons_dsfr}
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage_dsfr(
  radioButtons_dsfr(inputId = "inRadioButtons", 
                    label = "Input radio buttons",
                    choices = c("Item A","Item B", "Item C")),
  actionButton_dsfr("go","Change")
)

server <- function(input, output, session) {
  
  observeEvent(input$go,{
    updateRadioButtons_dsfr(
      session = session, 
      inputId = "inRadioButtons",
      label = "Un nouveau label",
      choices = c("A" = "a")
    )
  })
  
  observeEvent(input$inRadioButtons,{
    message(input$inRadioButtons)
  })
}

shinyApp(ui, server)
}

```

  

  






