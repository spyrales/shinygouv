---
title: "flat_new_one.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = TRUE)
```

Le développement du composant shiny `radioButton_dsfr` nécessite quelques étapes supplémentaires.
En effet, le code html de ce type de composant se structure en plusieurs htmlTemplates.

```
<div class="fr-form-group">
    <fieldset class="fr-fieldset">
        <legend class="fr-fieldset__legend fr-text--regular" id='radio-legend'>
            Légende pour l’ensemble de champs
        </legend>
        <div class="fr-fieldset__content">
            <div class="fr-radio-group">
                <input type="radio" id="radio-1" name="radio">
                <label class="fr-label" for="radio-1">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-2" name="radio">
                <label class="fr-label" for="radio-2">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-3" name="radio">
                <label class="fr-label" for="radio-3">Label radio
                </label>
            </div>
        </div>
    </fieldset>
</div>
```

Il est donc nécessaire de scinder les htmlTemplates dans différents fichiers .html.
Suivre les 2 premières étape de la procédure décrite dans `dev/documentation/comment-faire-un-composant-shiny.Rmd` uniquement pour la partie `<div class="fr-radio-group">`.

Quelques précisions: 
- Pour utiliser le fonctionnement classique du radioButtons {shiny}:
  - l'argument `value` a été rajouté
  - la classe `shiny-options-group` a été rajouté (ce qui permettra d'implémenter/utiliser une fonction `updateRadioButtons_dsfr()`)
  - reprendre la div `label` du radioButtons de shiny ainsi que ses attributs.
  
# radioButtons_unique_dsfr_template

Avant l'utilisation de `htmlTemplate()`, notre fonction nécessite de considérer les différents cas de figure pour certains paramètres.
Par exemple, l'utilisation ou non d'un vecteur nommé doit modifier la personnalisation du template `.html` (si le vecteur n'est pas nommé alors le `nom_choix` doit être égal au `value_choix`).


```{r, eval = FALSE}
radioButtons_unique_dsfr_template <-
  function(inputId,
           choix,
           nom_choix,
           name,
           checked = FALSE,
           inline = FALSE
  ){
  if(isTRUE(inline)){
    class_inline <- "-inline"  
  } else { 
    class_inline <- NULL}
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "radiobouton.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    name = name,
    nom_choix = nom_choix,
    checked = if (checked) "checked" else NULL,
    value_choix = choix,
    class_inline = class_inline 
  )
}
```


```{r function-radioButtons_unique_dsfr_template}
#' radioButtons_unique_dsfr_template
#' 
#' @param inputId id de l'input avec indexation
#' @param choix choix une valeur a selectionner 
#' @param nom_choix le nom de la valeur a selectionner/afficher
#' @param name nom de l'inputId sans indexation
#' @param checked Si TRUE, ajoute l'attribut checked
#' @param inline Si TRUE, positionne les choix en ligne (c'est-à-dire horizontalement). 
#'
#' @importFrom htmltools htmlTemplate
#' @return html
radioButtons_unique_dsfr_template <-
  function(inputId,
           choix,
           nom_choix,
           name,
           checked = FALSE,
           inline = FALSE
           
  ){
  if(isTRUE(inline)){
    class_inline <- "-inline"  
  } else { 
    class_inline <- NULL}
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "radiobouton.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    name = name,
    nom_choix = nom_choix,
    value_choix = choix,
    checked = if (checked) "checked" else NULL,
    class_inline = class_inline 
    )
}

```
  
  
```{r tests-radioButtons_unique_dsfr_template}
test_that("radioButtons_unique_dsfr_template works", {
  expect_true(inherits(radioButtons_unique_dsfr_template, "function")) 
  
    test <- radioButtons_unique_dsfr_template(
      inputId = "test-1",
      name = "test",
      choix = c("A"),
      nom_choix = "Choix A"
    )
  
  #' @description tester si tous les params sont remplaces
  expect_false(grepl(pattern = "\\{\\{", test))
})
```

Le travail précedemment réalisé, peut maintenant être répeté au niveau de la `<div class="fr-form-group">`:

- 2 première étape de la procédure `dev/documentation/comment-faire-un-composant-shiny.Rmd`.

# radioButtons_dsfr_template

De la même manière que pour la fonction précédente, il est nécessaire d'adapter la personnalisation en fonction des paramètres passés en arguments.
Cette fonction repose sur `radioButtons_unique_dsfr_template()` qui devra être répeter autant de fois qu'il y a de choix (utilisation de `purrr::map(...)`)

```{r, eval = FALSE}
radioButtons_dsfr_template <-
  function(inputId,
           label,
           choix,
           selected = NULL,
           inline = FALSE,
           class = NULL
           
  ){
  inline <- FALSE #TODO 
  if (isTRUE(inline)){
    class_inline <- "fr-fieldset--inline"
    class <- "shiny-input-container-inline"
  } else {
    class_inline = NULL
  }

  if (is.null(names(choix))) {
    nom_choix <- choix
  } else {
    nom_choix <- names(choix)
  }

  
  x <- 0
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant",
      "radiobouton_group.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    label = label,
    choix = purrr::map2(.x = choix,
                        .y = nom_choix
                       ~ {
                         x <<- x+1
                         radioButtons_unique_dsfr_template(
                           inputId = paste0(inputId,"-", x),
                           name = inputId,
                           choix = .x,
                           nom_choix = nom_choix,
                           checked = identical(.x, selected), 
                           inline = inline
                         )
                       }) %>%
      htmltools::tagList(),
    inline = class_inline, 
    class = class
  )
}
```

```{r function-radioButtons_dsfr_template}
#' radioButtons_dsfr_template
#' 
#' @param inputId id de l'input
#' @param label label du bouton
#' @param choix choix Liste des valeurs à sélectionner (si les éléments de la liste portent un nom, c'est ce nom qui est affiché à l'utilisateur et non la valeur)
#' @param selected Element sélectionné (NULL par defaut)
#' @param inline Si TRUE, positionne les choix en ligne (c'est-à-dire horizontalement). NON IMLPEMENTE
#' @param class des classes a ajouter si necessaire
#' 
#' @importFrom htmltools htmlTemplate tagList
#' @importFrom purrr map2 map_chr
#' @return html
radioButtons_dsfr_template <- function(inputId, label, choix, selected = NULL, inline = FALSE,  class = NULL
  ){
  inline <- FALSE #TODO 
  if (isTRUE(inline)){
    class_inline <- "fr-fieldset--inline"
    class <- "shiny-input-container-inline"
  } else {
    class_inline = NULL
  }
  
  if (is.null(names(choix))) {
    nom_choix <- choix
  } else {
    nom_choix <- names(choix)
  }

  
  x <- 0
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant",
      "radiobouton_group.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    label = label,
    choix = purrr::map2(.x = choix,
                        .y = nom_choix,
                       ~ {
                         x <<- x+1
                         radioButtons_unique_dsfr_template(
                           inputId = paste0(inputId,"-", x),
                           name = inputId,
                           choix = .x,
                           nom_choix = .y,
                           checked = identical(.x, selected),
                           inline = inline
                         )
                       }) %>%
      htmltools::tagList(),
    inline = class_inline, 
    class = class
  )
}

```
  
  
```{r tests-radioButtons_dsfr_template}
test_that("radioButtons_dsfr_template works", {
  expect_true(inherits(radioButtons_dsfr_template, "function")) 
  
    test <- radioButtons_dsfr_template(
      inputId = "test",
      label = "Test",
      choix = c("A","B"),
      class = NULL
    )
  
  #' @description tester si tous les params sont remplaces
  expect_false(grepl(pattern = "\\{\\{", test))
})
```

L'implementation de la fonction `radioButtons_dsfr()` reste quant à elle similaire à la suite de la procédure.

# radioButtons_dsfr

```{r function-radioButtons_dsfr}
#' radioButtons_dsfr
#' 
#' @param inputId id de l'input
#' @param label label du bouton
#' @param choices Liste des valeurs à sélectionner (si les éléments de la liste portent un nom, c'est ce nom qui est affiché à l'utilisateur et non la valeur)
#' @param selected Element sélectionné (NULL par défaut)
#' @param inline Si TRUE, positionne les choix en ligne (c'est-à-dire horizontalement). 
#' @param class des classes a ajouter si necessaire 
#' @return html
#' 
#' @export
#'
#' @examples
radioButtons_dsfr <- function(
  inputId, label, choices, selected = NULL, inline = FALSE, class = NULL  
  ) {
  
  # check les params
  assertthat::assert_that(is.character(inputId))
  assertthat::assert_that(is.character(label))
  assertthat::assert_that(is.character(choices))
  assertthat::assert_that(length(selected) <= 1)
  assertthat::assert_that(is.logical(inline)) 
  
    radioButtons_dsfr_template(
    inputId = inputId,
    label = label,
    choix = choices,
    selected = selected,
    inline = inline, 
    class = class
    ) %>%
      parse_html()

}
```

```{r examples-radioButtons_dsfr}
radioButtons_dsfr(
      inputId = "test", label = "Test", choices = c("A","B"), class = NULL
)

# radioButtons_dsfr(
#       inputId = "test",
#       label = "Test",
#       choices = c("Choix A" = "A","Choix B" = "B"),
#       class = NULL
# )
```

```{r tests-radioButtons_dsfr}
test_that("radioButtons_dsfr works", {
  test <- radioButtons_dsfr(
    inputId = "test", label = "Test", choices = c("A","B"), class = NULL
  )
  #' @description tester si shiny.tag
  expect_s3_class(test, "shiny.tag")
})
```

# updateRadioButtons_dsfr
    
```{r function-updateRadioButtons_dsfr}
#' updateRadioButtons_dsfr
#' 
#' @param inputId id de l'input
#' @param label label du bouton
#' @param choices Liste des valeurs à sélectionner (si les éléments de la liste portent un nom, c'est ce nom qui est affiché à l'utilisateur et non la valeur)
#' @param selected Element selectionné
#' @param session la session, la valeur par défaut est getDefaultReactiveDomain().
#' @importFrom htmltools tagList
#' @importFrom purrr map2
#' @return html
#' 
#' @export
updateRadioButtons_dsfr <- function(inputId,
                                    label = NULL,
                                    choices = NULL,
                                    selected = NULL,
                                    session = shiny::getDefaultReactiveDomain()) {
  ns <- session$ns
  x <- 0

  if (!is.null(choices)) {
    choices <- tags$div(
      class = "fr-fieldset__content shiny-options-group",
      tagList(purrr::map2(
        .x = choices,
        .y = names(choices),
        ~ {
          x <<- x + 1
          radioButtons_unique_dsfr_template(
            inputId = paste0(ns(inputId), "-", x),
            name = ns(inputId),
            choix = .x,
            nom_choix = .y,
            checked = identical(.x, selected),
            inline = FALSE
          )
        }
      ))
    )
  }

  
  message <- utils::getFromNamespace("dropNulls", "shiny")(
    list(
      label = label,
      options = as.character(choices)
    )
  )

  session$sendInputMessage(inputId, message)
}
    

```
  
```{r example-updateRadioButtons_dsfr}
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage_dsfr(
  radioButtons_dsfr(inputId = "inRadioButtons", 
                    label = "Input radio buttons",
                    choices = c("Item A","Item B", "Item C")),
  actionButton_dsfr("go","Change")
)

server <- function(input, output, session) {
  
  observeEvent(input$go,{
    updateRadioButtons_dsfr(
      session = session, 
      inputId = "inRadioButtons",
      label = "Un nouveau label",
      choices = c("A" = "a")
    )
  })
  
  observeEvent(input$inRadioButtons,{
    message(input$inRadioButtons)
  })
}

shinyApp(ui, server)
}

```
  
```{r tests-updateRadioButtons_dsfr}
test_that("updateRadioButtons_dsfr works", {
  expect_true(inherits(updateRadioButtons_dsfr, "function")) 
})
```
  





```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly


spec_infalte <- function(){
  nom <- "radioButtons dsfr"
  fusen::inflate(
    flat_file = "dev/flat_composants/flat_radioButtons.Rmd", 
    vignette_name = nom)
  
  nom_c <- gsub(x = tolower(nom), "\\s", "-")
  nom_file <- paste0(nom_c, ".Rmd")
  file.copy(
    file.path("vignettes", nom_file),
    file.path("dev","documentation", nom_file)
    )
  
  unlink(file.path("vignettes", nom_file))
}
spec_infalte()

```

