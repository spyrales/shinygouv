---
title: "flat_new_one.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = TRUE)
```

Le développement du composant shiny `radioButton_dsfr` nécessite quelques étapes supplémentaires.
En effet, le code html de ce type de composant se structure en plusieurs htmlTemplates.

```
<div class="fr-form-group">
    <fieldset class="fr-fieldset">
        <legend class="fr-fieldset__legend fr-text--regular" id='radio-legend'>
            Légende pour l’ensemble de champs
        </legend>
        <div class="fr-fieldset__content">
            <div class="fr-radio-group">
                <input type="radio" id="radio-1" name="radio">
                <label class="fr-label" for="radio-1">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-2" name="radio">
                <label class="fr-label" for="radio-2">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-3" name="radio">
                <label class="fr-label" for="radio-3">Label radio
                </label>
            </div>
        </div>
    </fieldset>
</div>
```

Il est donc nécessaire de scinder les htmlTemplates dans différents fichiers .html.
Suivre les 2 premières étape de la procédure décrite dans `dev/documentation/comment-faire-un-composant-shiny.Rmd` uniquement pour la partie `<div class="fr-radio-group">`.

Quelques précisions: 
- Pour utiliser le fonctionnement classique du radioButtons {shiny}:
  - l'argument `value` a été rajouté

# radioButtons_unique_dsfr_template

Avant l'utilisation de `htmlTemplate()`, notre fonction nécessite de considérer les différents cas de figure pour certains paramètres.
Par exemple, l'utilisation ou non d'un vecteur nommé doit modifier la personnalisation du template `.html` (si le vecteur n'est pas nommé alors le `name_choix` doit être égal au `value_choix`).


```{r, eval = FALSE}
radioButtons_unique_dsfr_template <- function(inputId, choix, name, inline = FALSE
  ){
  
 if (is.null(names(choix))) {
    name_choix <- choix} else {
    name_choix <- names(choix)
    }
  
  
  if(isTRUE(inline)){
    class_inline <- "-inline"  
  } else { 
    class_inline <- NULL}
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "radiobouton.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    name = name,
    name_choix = name_choix,
    value_choix = choix,
    class_inline = class_inline 
    )
}
```


```{r function-radioButtons_unique_dsfr_template}
#' radioButtons_unique_dsfr_template
#' 
#' @param inputId id de l'input avec indexation
#' @param choix choix Liste des valeurs à sélectionner (si les éléments de la liste portent un nom, c'est ce nom qui est affiché à l'utilisateur et non la valeur)
#' @param name nom de l'inputId sans indexation
#' @param inline Si TRUE, positionne les choix en ligne (c'est-à-dire horizontalement). 
#'
#' @importFrom htmltools htmlTemplate
#' @return html
radioButtons_unique_dsfr_template <- function(inputId, choix, name, inline = FALSE
  ){
  
 if (is.null(names(choix))) {
    name_choix <- choix} else {
    name_choix <- names(choix)
    }
  
  
  if(isTRUE(inline)){
    class_inline <- "-inline"  
  } else { 
    class_inline <- NULL}
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "radiobouton.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    name = name,
    name_choix = name_choix,
    value_choix = choix,
    class_inline = class_inline 
    )
}

```
  
  
```{r tests-radioButtons_unique_dsfr_template}
test_that("radioButtons_unique_dsfr_template works", {
  expect_true(inherits(radioButtons_unique_dsfr_template, "function")) 
  
    test <- radioButtons_unique_dsfr_template(
      inputId = "test-1",
      name = "test",
      choix = c("Choix A" = "A")
    )
  
  #' @description tester si tous les params sont remplaces
  expect_false(grepl(pattern = "\\{\\{", test))
})
```

Le travail précedemment réalisé, peut maintenant être répeté au niveau de la `<div class="fr-form-group">`:

- 2 première étape de la procédure `dev/documentation/comment-faire-un-composant-shiny.Rmd`.

# radioButtons_dsfr_template

De la même manière que pour la fonction précédente, il est nécessaire d'adapter la personnalisation en fonction des paramètres passés en arguments.
Cette fonction repose sur `radioButtons_unique_dsfr_template()` qui devra être répeter autant de fois qu'il y a de choix (utilisation de `purrr::map(...)`)

```{r, eval = FALSE}
radioButtons_dsfr_template <- function(inputId, label, choix, inline = FALSE,  class = NULL
  ){
  inline <- FALSE #TODO 
  if (isTRUE(inline)){
    class_inline <- "fr-fieldset--inline"
    class <- "shiny-input-container-inline"
  } else {
    class_inline = NULL
  }
  x <- 0
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant",
      "radiobouton_group.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    label = label,
    choix = purrr::map(.x = choix, 
                       ~ {
                         x <<- x+1
                         radioButtons_unique_dsfr_template(
                           inputId = paste0(inputId,"-", x),
                           name = inputId,
                           choix = .x,
                           inline = inline
                         )
                       }) %>%
      htmltools::tagList(),
    inline = class_inline, 
    class = class
  )
}
```

```{r function-radioButtons_dsfr_template}
#' radioButtons_dsfr_template
#' 
#' @param inputId id de l'input
#' @param label label du bouton
#' @param choix choix Liste des valeurs à sélectionner (si les éléments de la liste portent un nom, c'est ce nom qui est affiché à l'utilisateur et non la valeur)
#' @param inline Si TRUE, positionne les choix en ligne (c'est-à-dire horizontalement). NON IMLPEMENTE
#' @param class des classes a ajouter si necessaire
#' 
#' @importFrom htmltools htmlTemplate tagList
#' @importFrom purrr map map_chr
#' @return html
radioButtons_dsfr_template <- function(inputId, label, choix, inline = FALSE,  class = NULL
  ){
  
  inline <- FALSE #TODO 
  if (isTRUE(inline)){
    class_inline <- "fr-fieldset--inline"
    class <- "shiny-input-container-inline"
  } else {
    class_inline = NULL
  }
  x <- 0
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant",
      "radiobouton_group.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    label = label,
    choix = purrr::map(.x = choix, 
                       ~ {
                         x <<- x+1
                         radioButtons_unique_dsfr_template(
                           inputId = paste0(inputId,"-", x),
                           name = inputId,
                           choix = .x,
                           inline = inline
                         )
                       }) %>%
      htmltools::tagList(),
    inline = class_inline, 
    class = class
  )
}

```
  
  
```{r tests-radioButtons_dsfr_template}
test_that("radioButtons_dsfr_template works", {
  expect_true(inherits(radioButtons_dsfr_template, "function")) 
  
    test <- radioButtons_dsfr_template(
      inputId = "test",
      label = "Test",
      choix = c("A","B"),
      class = NULL
    )
  
  #' @description tester si tous les params sont remplaces
  expect_false(grepl(pattern = "\\{\\{", test))
})
```

L'implementation de la fonction `radioButtons_dsfr()` reste quant à elle similaire à la suite de la procédure.

# radioButtons_dsfr

```{r function-radioButtons_dsfr}
#' radioButtons_dsfr
#' 
#' @param inputId id de l'input
#' @param label label du bouton
#' @param choices Liste des valeurs à sélectionner (si les éléments de la liste portent un nom, c'est ce nom qui est affiché à l'utilisateur et non la valeur)
#' @param inline Si TRUE, positionne les choix en ligne (c'est-à-dire horizontalement). 
#' @param class des classes a ajouter si necessaire 
#' @return html
#' 
#' @export
#'
#' @examples
radioButtons_dsfr <- function(
  inputId, label, choices, inline = FALSE, class = NULL  
  ) {
  
  # check les params
  assertthat::assert_that(is.character(inputId))
  assertthat::assert_that(is.character(label))
  assertthat::assert_that(is.character(choices))
  assertthat::assert_that(is.logical(inline))  
  
    radioButtons_dsfr_template(
    inputId = inputId,
    label = label,
    choix = choices,
    inline = inline, 
    class = class
    ) %>%
      parse_html()

}
```

```{r examples-radioButtons_dsfr}
radioButtons_dsfr(
      inputId = "test", label = "Test", choices = c("A","B"), class = NULL
)

# radioButtons_dsfr(
#       inputId = "test", 
#       label = "Test", 
#       choices = c("Choix A" = "A","Choix B" = "B"),
#       class = NULL
# )
```

```{r tests-radioButtons_dsfr}
test_that("radioButtons_dsfr works", {
  test <- radioButtons_dsfr(
    inputId = "test", label = "Test", choices = c("A","B"), class = NULL
  )
  #' @description tester si shiny.tag
  expect_s3_class(test, "shiny.tag")
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly


spec_infalte <- function(){
  nom <- "radioButtons dsfr"
  fusen::inflate(
    flat_file = "dev/flat_composants/flat_radioButtons.Rmd", 
    vignette_name = nom)
  
  nom_c <- gsub(x = tolower(nom), "\\s", "-")
  nom_file <- paste0(nom_c, ".Rmd")
  file.copy(
    file.path("vignettes", nom_file),
    file.path("dev","documentation", nom_file)
    )
  
  unlink(file.path("vignettes", nom_file))
}
spec_infalte()

```

