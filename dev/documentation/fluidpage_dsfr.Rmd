---
title: "fluidPage_dsfr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{fluidpage_dsfr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(shinygouv)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/flat_composants/flat_fluidpage.Rmd: do not edit by hand -->

Documentation sur l'implementation des composants `fluidPage_dsfr`, `fluidRow_dsfr` et les columns.

Nous allons dans un premier temps nous attaquer au fluidPage.


# fluidPage_dsfr_template

Comme expliqué dans le workflow de création des composants, nous avons un fichier `html` dans le dossier `inst/v1.7.2/composant/fluidpage.html`. Celui ci reprend la structure de base de la page pour dsfr.

Ensuite, vient la traduction avec `htmlTemplate` :


```{r eval = FALSE, echo = TRUE}
fluidPage_dsfr_template <- function(
    header,
    title,
    body
){
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "fluidpage.html",
      package = "shinygouv"
    ),
    header = NULL
    title = title,
    body = body
  )
}
```

Les paramètres `header`, `title` et `body` sont repris dans le html pour pouvoir le créer.


# fluidPage_dsfr

Le template étant défini, nous allons pourvoir apporter notre logique métier dans la fonction `fluidPage_dsfr`. Pour ça, la fonction reprend le template précédent. Ensuite, cette fonction permet d'ajouter une logique sur les paramètres, comme checker avec des assertthat ou autre.

Aussi, c'est ici que nous ajoutons les dépendences à notre application avec `add_dsfr_deps`. Autrement dit, nous chargons à cet endroit le css, js et autres.

Petit détail technique, le `parse_html` n'est pas appliqué exceptionnellement dans le `fluidPage_dsfr`afin de conserver les dépendances des `htmlwidgets`.
Il est donc à noter qu'il ne sera pas possible de faire des tags Attributes sur l'objet `ui`.


```{r eval = FALSE, echo = TRUE}
fluidPage_dsfr <- function(
    ...,
    header = NULL,
    title = NULL,
    theme = NULL,
    lang = NULL
) {
  
  # TODO theme et lang
  # check les params
  ui <- fluidPage_dsfr_template(
    header = tagList(header),
    title = tagList(title),
    body = tagList(
      ...
      )
  ) %>%
    parse_html(zone = "/html") %>% 
    add_dsfr_deps() 
  ui
  
}
```

```{r examples-fluidPage_dsfr, eval = FALSE}
my_page <- fluidPage_dsfr(
  header = header_dsfr(
     intitule = "Prefet de", 
     officiel = "Bretagne",
  ),
  title = "Gouv",
  htmltools::div("test")
)
if(interactive()){
shiny::shinyApp(
  my_page,
  server = function(input, output){}
  )
}
```

# fluidRow_dsfr

Voici un autre exemple pour les layouts. Un ensemble de fonction va reposer sur un seul template, celui du layout. On trouve alors un fichier `html` dans un dossier `layout`.


```{r echo = TRUE, eval = FALSE}
layout_dsfr_template <- function(
    html,
    class,
    other_class
){
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "layout", 
      "layout.html",
      package = "shinygouv"
    ),
    html = html,
    class = class,
    other_class = other_class
  )
}
```

Avec cette fonction, on va pouvoir initier tout un ensemble d'éléments pour notre application, comme les fluidRow, les containers et les columns


## Exemple pour fluidRow_dsfr

On reprend le template layout et on ajoute notre logique métier sur les paramètres.


  

```{r example-fluidRow_dsfr}

if(interactive()){
shiny::shinyApp(
  ui = fluidPage_dsfr(
    title = "exemple",
    fluidRow_dsfr(
      shiny::p("Voici un exemple")
    )
  ),
  server = function(input, output){}
  )
}

```

  

## Exemple avec les colonnes

Le fonctionnement des colonnes est un peu différent pour le dsfr. Si la largeur n'est pas précisée alors la taille des colonnes est automatiquement calculée en fonction du nombre. Mais on a quand même la possibilité de changer la taille comme dans {shiny}. Nous allons donc implementer cette logique en essayant de penser à la conversion de nos applications.


  


```{r echo = TRUE, eval = FALSE}
column_dsfr <- function(width = NULL, ...){
  
  if(is.null(width)) {
    add_width <- ""
    }else{
      if(width != 0){
        add_width <- paste0("-", width)
      }else{
        add_width <- ""
      }
    }

  class <- paste0("fr-col", add_width)
  
  layout_dsfr_template(
      html = tagList(
        ...
      ),
      class = class,
      other_class = NULL
    )
}
```

  

```{r example-column_dsfr}

if(interactive()){
shiny::shinyApp(
  ui = fluidPage_dsfr(
    title = "exemple",
    fluidRow_dsfr(
      column_dsfr(0, "test"),
      column_dsfr(0, "test"),
      column_dsfr(0, "test"),
      column_dsfr(0, "test")
    )
  ),
  server = function(input, output){}
  )
}

```

  

## Conclusion

Voila plusieurs exemples d'implémentation de composants/layouts qui ne demandent pas d'intéraction avec {shiny}. Vous pouvez reproduire ce processus avec les [cartes](https://gouvfr.atlassian.net/wiki/spaces/DB/pages/222331445/Carte+-+Card) ou les [alertes](https://gouvfr.atlassian.net/wiki/spaces/DB/pages/736362500/Alertes+-+Alerts).


