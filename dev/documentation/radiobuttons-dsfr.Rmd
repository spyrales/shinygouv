---
title: "radioButtons dsfr"
output: github_document
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(shinygouv)
```

<!-- WARNING - This vignette is generated by {fusen} from /dev/v1.7.2/composant/flat_radioButtons.Rmd: do not edit by hand -->

Le développement du composant shiny `radioButton_dsfr` nécessite quelques étapes supplémentaires.
En effet, le code html de ce type de composant se structure en plusieurs htmlTemplates.

```
<div class="fr-form-group">
    <fieldset class="fr-fieldset">
        <legend class="fr-fieldset__legend fr-text--regular" id='radio-legend'>
            Légende pour l’ensemble de champs
        </legend>
        <div class="fr-fieldset__content">
            <div class="fr-radio-group">
                <input type="radio" id="radio-1" name="radio">
                <label class="fr-label" for="radio-1">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-2" name="radio">
                <label class="fr-label" for="radio-2">Label radio
                </label>
            </div>
            <div class="fr-radio-group">
                <input type="radio" id="radio-3" name="radio">
                <label class="fr-label" for="radio-3">Label radio
                </label>
            </div>
        </div>
    </fieldset>
</div>
```

Il est donc nécessaire de scinder les htmlTemplates dans différents fichiers .html.
Apr les 2 premières étape de la procédure décrite dans 'dev/documentation/comment-faire-un-composant-shiny.Rmd' uniquement pour la partie `<div class="fr-radio-group">'.

Quelques précisions: 
- l'id n'est pas à conserver dans le template '.html' afin de ne pas avoir de conflit avec les id shiny. Celui ci sera géré au niveau du template 'parent' (radiodouton_group.html)
- Pour se rapprocher au plus près du code du radioButtons {shiny}:
  - l'argument `value` a été rajouté
  - le 'label' a été remplacé par un 'span'
  - l'argument `for` a été supprimé


# radioButtons_unique_dsfr_template

Avant l'utilisation de 'htmlTemplate()', notre fonction nécessite de considérer les différents cas de figure pour certains paramètres.
Par exemple, l'utilisation ou non d'un vecteur nommé doit modifier la personnalisation du template '.html'.



```{r eval = FALSE}
radioButtons_unique_dsfr_template <- function(inputId, choix, inline = FALSE
  ){
  
 if (is.null(names(choix))) {
    name_choix <- choix
    } else {
    name_choix <- names(choix)
    }
  
  #TODO
  if(isTRUE(inline)){
    class_inline <- "-inline"  
  } else { 
    class_inline <- NULL}
  
  htmltools::htmlTemplate(
    filename = system.file(
      "v1.7.2",
      "composant", 
      "radiobouton.html",
      package = "shinygouv"
    ),
    inputId = inputId,
    name_choix = name_choix,
    value_choix = choix,
    class_inline = class_inline
    )
}
```

  
  

Le travail précemment réalisé, peut maintenant être répeté au niveau de la `<div class="fr-form-group">`. 
- 2 première étape de la procédure 'dev/documentation/comment-faire-un-composant-shiny.Rmd'.


# radioButtons_dsfr_template

De la même manière que pour la fonction précédente, il est nécessaire d'adapter la personnalisation en fonction des paramètres passés en arguments.
Cette fonction repose sur `radioButtons_unique_dsfr_template()` qui devra être répeter autant de fois qu'il y a de choix (utilisation de 'purrr::map(...)')


  
  

L'implementation de la fonction `radioButtons_dsfr()` reste quant à elle similaire à la suite de la procédure.


# radioButtons_dsfr

```{r examples-radioButtons_dsfr, eval = FALSE}
radioButtons_dsfr(
      inputId = "test", label = "Test", choices = c("A","B"), class = NULL
)

radioButtons_dsfr(
      inputId = "test", 
      label = "Test", 
      choices = c("Choix A" = "A","Choix B" = "B"),
      class = NULL
)
```

